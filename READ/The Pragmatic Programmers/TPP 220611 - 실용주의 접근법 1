## 날짜
2022.06.11.(토)

## 읽은 범위
2장 실용주의 접근법

## 팁
  * 어설픈 변명 말고 대안을 제시하라
  * 변화의 촉매가 되어라
  * 항상 큰 그림을 기억하라
  * 무엇을 말하는가와 어떻게 말하는가 모두 중요하다

## 내용
### **좋은 설계의 핵심** 
좋은 설계란 바꾸기 쉬운 설계(Easier To Change)이다. 결합도를 줄이고 응집도를 높이는 방향으로 클래스, 메소드를 설계해야 한다. 클래스의 책임이 분명하고 크기가 작을수록 변화에 대응하기 쉽다.

### **DRY**
개발 과정에서 여러 형태의 중복이 생길 수 있다. 중복이란 변경이 일어날 때 동일한 기능을 하는 다른 곳을 함께 변경해야 하는 경우이다.
* **코드 중복**: 메소드 책임이 잘 분리되지 않은 경우
* **데이터 중복**: 기존 필드로 표현 가능한 데이터 선언
```kotlin
class LIne {
  Point start
  Point end
  int length // 기존 멤버로부터 알 수 있는 종속적인 멤버
}
```
* **표현 중복**: 개발자 간 중복된 클래스 정의, 외부 API 연동(여러 언어에서 사용하도록 재정의), DB 스키마 등  
  => 자동화 툴/중앙 저장소 공유/일일 스크럼 등

### **직교성**
책임이 잘 분리된 설게와 아키텍처는 한 계층이 다른 계층에 큰 영향을 주지 않는다. 컴포넌트는 독립적으로 존재할 수 있어야 하며, 요구사항의 변경이 여러 컴퓨넌트에 영향을 미쳐선 안 된다. 컴포넌트/클래스가 서로 독립적으로 기능하는 것을 **직교성**이라 한다.
  * 레이어 구분, 아키텍처 패턴 등으로 이를 달성할 수 있다.
  * *ex) 사용자 인터페이스와 데이터베이스*

### **가역성**
프로젝트의 각 컴포넌트는 교체 가능해야 하며, 되돌릴 수 있어야 한다. RDB에서 No SQL DB로 변경하는 데에 감당할 수 없는 비용을 치뤄서는 안 된다. 이를 위해 계층이나 외부 솔루션에 의존하는 컴포넌트를 추상화하여 활용할 수 있다.

## 인용구
> "프로그래머는 늘 유지보수 모드에 있다. 우리의 이해는 날마다 바뀐다. 우리가 프로젝트에 열중해 있는 동안에도 새로운 요구 사항이 도착하고 기존 요구 사항은 진화한다. 어쩌면 환경이 변할 수도 있다. 유지 보수는 별개의 활동이 아니며 전체 개발 과정의 일상정인 부분이다." - 42p

> "여러분이 특정 업체의 데이터베이스나 아키텍처 패턴, 배포 모델을 사용하기로 결정했다면 큰 비용을 치르지 않고는 되돌릴 수 없는 행동을 하기로 묶여버린 셈이다." - 67p